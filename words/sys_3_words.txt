data
examples
int
myvalue
allocates
bytes
of
memory
char
character
array
with
elements
allocates
bytes
of
memory
terminates
string
memory
layout
stack
program
stack
constant
variables
heap
dynamic
memory
allocation
uninitialized
data
bss
global
variables
initialized
data
global
variables
with
values
high
address
low
address
stack
heap
uninitialized
data
bss
initialized
data
text
special
registers
used
by
cpu
to
track
results
of
logic
and
the
state
of
the
processor
extended
instruction
points
to
next
instruction
to
be
executed
bss
example
int
int
main
return
initialized
variables
global
variables
static
local
variables
created
with
static
command
memory
rodata
example
int
int
main
return
data
types
in
c
bit
type
explanation
data
size
char
single
character
to
or
to
int
integer
to
long
long
int
to
float
decimal
to
double
decimal
to
global
variables
scope
variables
available
throughout
entire
program
static
memory
allocation
virtual
address
space
mapped
to
physical
address
at
runtime
core
technical
bootcamp
systems
security
debugging
binaries
learning
objectives
at
the
end
of
this
you
should
be
able
in
the
memory
heap
stack
registers
describe
basic
including
mov
jmp
use
nasm
to
assemble
code
use
ld
to
link
code
c
code
statement
global
variable
definitions
main
function
int
extension
extension
cpp
extension
preprocessor
directives
directives
executed
before
the
compilation
process
allows
inclusion
of
additional
code
files
compile
time
constants
conditionals
used
for
directives
registers
specific
memory
addresses
stores
temporary
data
for
use
by
cpu
and
other
components
general
registers
segment
registers
offset
registers
special
registers
bss
block
started
by
symbol
uninitialized
objects
global
outside
of
functions
static
local
variables
created
with
static
command
assembly
compilation
process
basic
assembly
mov
dest
add
dest
sub
dest
xor
dest
inc
dest
dec
dest
jmp
call
dest
ret
endian
example
consider
putting
the
string
into
memory
locations
starting
at
memory
big
endian
little
endian
letters
w
o
r
d
hex
values
big
vs
little
endian
endian
determines
how
data
gets
written
to
memory
big
bits
written
first
little
bits
written
first
see
gray
hat
th
pp
vs
nasm
used
by
gnu
assemblers
gcc
often
used
by
linux
nasm
often
used
by
windows
assemblers
objdump
can
disassemble
assembly
code
objdump
hello
file
format
disassembly
of
section
init
init
ec
sub
mov
rax
test
rax
rax
je
callq
add
retq
c
pointers
points
to
the
memory
address
of
a
variable
printf
var
int
main
char
printf
return
nasm
vs
nasm
cmd
dest
comments
no
designate
for
eip
no
designate
for
cmd
dest
comments
before
eip
to
designate
pointer
declarations
in
a
variable
can
be
set
to
hold
the
memory
address
char
is
a
char
ptr
int
int
varptr
assembly
example
section
declaration
global
must
export
the
entry
point
to
the
elf
linker
mov
message
length
mov
pointer
to
message
to
write
mov
file
handle
stdout
mov
call
number
int
kernel
exit
mov
syscall
exit
code
mov
call
number
int
kernel
section
declaration
msg
db
string
len
equ
msg
of
our
string
general
registers
major
calculations
extra
storage
bit
counter
register
extension
for
aex
bit
versions
bit
high
order
byte
for
bit
low
order
byte
for
basic
rax
can
refer
to
specific
parts
of
rax
rax
eax
ah
ax
al
nasm
vs
example
mov
eax
comment
mov
eax
comment
offset
registers
extended
base
points
to
beginning
of
local
environment
for
a
function
extended
source
holds
the
data
source
offset
extended
destination
holds
the
destination
offset
extended
stack
points
to
the
top
of
the
stack
segment
registers
bits
hold
first
part
of
a
memory
address
point
to
stack
and
extra
data
segments
nasm
and
ld
nasm
use
to
assemble
assembly
code
and
create
linkable
nasm
ld
use
to
take
assembled
code
and
link
to
machine
language
ld
helloworld
exploit
once
it
is
determined
buffer
overflow
exists
determine
if
eip
can
be
overwritten
create
an
exploit
must
include
address
to
shellcode
nop
nop
sleds
load
shellcode
into
buffer
and
run
buffer
overflow
exploit
vulnerable
applications
write
past
end
of
buffer
strcpy
strcat
sprintf
vsprintf
overwrite
ebp
eip
register
eip
is
return
address
buffer
overflow
usually
strings
buffers
buffers
are
below
ebp
eip
potential
crash
application
expose
data
allow
code
injection
objdump
can
disassemble
assembly
code
objdump
hello
file
format
disassembly
of
section
init
init
ec
sub
mov
rax
test
rax
rax
je
callq
add
retq
nasm
and
ld
nasm
use
to
assemble
assembly
code
and
create
linkable
nasm
ld
use
to
take
assembled
code
and
link
to
machine
language
ld
helloworld
at
the
end
of
this
you
should
be
able
describe
shellcode
describe
the
purpose
of
null
and
the
importance
of
avoiding
them
in
shellcode
system
calls
list
can
be
found
at
usr
asm
exit
fork
read
write
open
close
execve
core
technical
bootcamp
opcodes
operation
code
the
machine
language
and
remember
hex
is
really
binary
xec
corresponds
to
sub
systems
shellcode
basics
first
last
january
null
characters
shellcode
loaded
into
buffer
by
strcpy
similar
since
null
characters
terminate
null
characters
in
shellcode
can
cause
the
code
to
not
load
fully
must
craft
shellcode
to
not
contain
null
characters
xor
write
to
write
to
standard
out
edx
contains
length
of
string
ecx
contains
address
of
string
ebx
contains
to
indicate
stdout
eax
contains
to
indicate
write
execve
used
to
execute
external
commands
format
is
int
execve
const
char
char
const
argv
char
const
envp
does
not
return
on
success
value
if
not
parameters
st
filename
or
script
with
nd
string
array
of
arguments
used
by
filename
first
argument
is
name
rd
key
value
string
pairs
passed
as
environments
kernel
int
interrupts
transfer
program
flow
to
interrupt
handler
transfers
to
system
call
linux
eax
register
is
used
for
system
call
parameters
need
are
ebx
first
parameter
ecx
second
parameter
edx
third
parameter
esi
fourth
parameter
edi
fifth
parameter
exposing
opcodes
you
can
expose
the
opcodes
with
objdump
gdb
can
use
disassemble
main
to
expose
the
opcodes
for
the
main
if
possible
once
you
have
the
put
them
into
a
string
with
to
designate
hex
codes
c
code
c
is
a
good
language
to
build
exploits
in
easier
to
understand
and
debug
the
opcodes
generated
will
be
large
include
create
extra
steps
for
smaller
this
may
not
work
harder
to
find
specific
opcodes
needed
may
include
extra
function
calls
that
will
thwart
shellcode
alert
the
sys
execve
register
eax
is
b
ebx
is
address
to
filename
ecx
is
address
of
argv
edx
is
zero
this
can
be
used
to
execute
sh
assembly
much
more
concise
opcode
harder
to
understand
and
debug
we
can
control
all
aspects
extra
creating
create
directly
in
hex
steep
learning
curve
create
in
c
or
other
high
level
language
create
in
assembly
find
online
or
use
a
tool
like
metasploit
covered
in
later
modules
buffer
stack
usually
strings
buffers
buffers
are
below
ebp
eip
potential
crash
application
expose
data
allow
code
injection
nop
sled
the
is
called
a
nop
a
nop
moves
the
eip
to
the
next
memory
a
nop
sled
is
a
technique
used
when
an
algorithm
branches
jmp
but
the
exact
address
know
the
nop
sled
ends
with
a
pointer
to
the
exploit
code
code
injection
once
buffer
overflow
condition
found
determine
if
you
can
control
eip
determine
addresses
determine
intended
attack
and
determine
shellcode
customized
shellcode
known
code
build
and
debug
shellcode
exploit
may
need
to
adjust
return
address
to
hit
nop
sled
properly
learning
objectives
at
the
end
of
this
you
should
be
able
describe
and
demonstrate
basic
shellcode
injection
describe
nop
and
how
to
implement
a
nop
sled
describe
integer
overflow
systems
shellcode
injections
first
last
january
core
technical
bootcamp
buffer
approach
vulnerable
buffer
ebp
eip
nop
sled
shellcode
repeated
address
esp
other
memory
stack
buffer
approach
vulnerable
buffer
ebp
eip
nop
sled
shellcode
single
address
esp
other
memory
stack
determining
addresses
with
access
to
use
gdb
or
ddd
disassemble
main
read
assembly
set
breakpoint
before
exit
run
code
with
buffer
input
determine
registers
ebp
esp
eip
off
by
one
errors
usually
occurs
with
counters
or
arrays
what
numbers
will
be
printed
by
this
python
for
x
in
consider
the
following
c
int
myarray
printf
myarray
string
terminator
the
terminating
character
for
a
string
is
note
that
is
not
equal
to
shellcode
needs
to
be
written
so
that
no
characters
occur
would
prevent
the
entire
shellcode
from
loading
into
the
integer
overflow
caused
by
register
operations
that
overflow
the
size
of
the
register
the
results
are
unpredictable
but
can
be
used
to
exploit
the
system
examples
of
ariane
rocket
original
donkey
kong
restricted
to
level
putting
exploit
together
create
or
download
shellcode
determine
number
of
nops
needed
on
approach
to
overwrite
eip
determine
desired
return
address
middle
of
nop
to
overwrite
eip
pass
nops
shellcode
return
address
to
buffer
variables
what
would
happen
if
we
tried
to
store
a
number
larger
than
a
variable
for
storing
to
a
byte
void
short
printf
determining
addresses
code
determine
size
of
buffer
feed
increasing
data
until
buffer
overflows
determine
address
from
if
possible
make
assumptions
about
environment
ebp
eip
data
types
in
c
type
explanation
data
size
char
single
character
byte
bits
int
integer
to
bytes
bits
short
integer
to
bytes
bits
long
integer
to
bytes
bits
float
decimal
to
bytes
bits
double
decimal
to
bytes
bits
core
technical
bootcamp
function
calls
prolog
stack
grows
low
mem
highmem
stack
frame
eip
parameter
parameter
ebp
buffers
esp
stack
registers
low
mem
highmem
stack
frame
esp
ebp
stack
grows
stack
review
used
for
functions
calls
and
local
variables
filo
last
each
process
gets
its
own
stack
in
the
stack
area
learning
objectives
at
the
end
of
this
you
should
be
able
demonstrate
a
full
buffer
overflow
with
shellcode
injection
systems
buffer
overflow
exploits
stack
calls
push
data
inserted
onto
stack
esp
will
always
be
stack
data
memory
pop
get
last
data
pushed
onto
stack
function
calls
arguments
pushed
onto
stack
usually
reverse
order
return
address
pushed
onto
stack
ebp
pushed
onto
stack
esp
copied
into
ebp
registers
exist
physically
on
cpu
faster
than
ram
extended
base
pointer
stack
grows
downward
from
ebp
lower
bit
bit
register
extended
stack
pointer
moves
to
lower
address
as
more
data
pushed
onto
stack
bit
bit
register
extended
instruction
pointer
next
memory
address
for
instructions
section
nop
sled
if
address
segmentation
fault
occurs
nop
sled
executes
next
statement
series
to
shellcode
allows
for
less
precise
address
success
is
more
likely
exploit
determine
buffer
address
many
ways
to
accomplish
this
write
data
into
buffer
so
that
it
writes
over
ebp
and
eip
when
function
eip
points
to
code
in
buffer
code
executes
shellcode
execution
if
application
had
privileges
setuid
shell
can
have
privileges
may
have
to
adjust
return
address
or
size
of
nop
sled
to
get
code
to
execute
properly
