applied
crypto
advanced
topics
today
sslstrip
review
everyone
remember
how
do
you
remember
how
to
execute
an
review
everyone
remembers
how
ssl
sslstrip
written
by
moxie
marlinspike
introduced
in
a
talk
at
black
hat
in
marlinspike
successfully
executed
it
as
an
exit
node
on
and
none
of
the
victims
recognized
the
mitm
how
it
works
adversary
first
executes
a
there
are
multiple
ways
to
do
marlinspike
ran
a
tor
exit
you
could
also
do
an
how
it
works
when
victim
types
in
something
like
usually
the
server
would
redirect
the
user
to
get
http
page
moved
to
how
it
works
adversary
grabs
the
plain
http
and
sends
an
https
request
to
the
get
get
how
it
works
the
adversary
sets
up
an
encrypted
connection
with
the
get
get
ssl
handshake
how
it
works
the
adversary
then
sends
plain
html
to
the
get
get
ssl
handshake
html
html
how
it
works
the
victim
never
even
had
a
secure
get
get
ssl
handshake
html
html
how
it
works
this
attack
relies
on
the
victim
not
noticing
the
absence
of
the
green
lock
defenses
hsts
http
strict
transport
security
web
servers
declare
that
browsers
should
only
interact
with
it
using
secure
https
the
only
time
this
is
vulnerable
is
the
first
time
a
client
connects
to
the
server
defenses
certificate
pinning
after
obtaining
the
the
client
checks
the
public
key
against
a
set
of
public
keys
for
the
server
these
hashes
are
bundled
with
the
defenses
https
upgrades
some
browsers
automatically
provide
https
catch
http
requests
and
try
to
upgrade
it
to
https
brave
browser
defenses
open
up
your
eyes
be
on
the
lookout
for
the
green
applied
crypto
advanced
topics
review
rsa
keys
today
tor
public
key
exchange
review
review
how
we
do
a
public
key
b
pub
b
pri
v
review
bob
has
an
rsa
key
pair
alice
generates
an
aes
key
k
k
b
pub
b
pri
v
review
alice
encrypts
her
aes
key
with
public
k
b
b
pub
pub
b
pri
v
review
bob
decrypts
with
his
private
key
to
find
k
b
pub
b
pri
v
k
onion
routing
is
a
method
to
obtain
anonymity
on
the
we
are
going
to
extend
the
ideas
learned
about
so
onion
routing
both
tor
nodes
have
rsa
key
b
c
pub
pub
b
c
priv
priv
tor
relay
tor
exit
node
onion
routing
alice
wants
to
talk
to
first
she
does
a
key
exchange
with
the
first
tor
pub
b
c
pub
pub
b
c
priv
priv
tor
relay
tor
exit
node
onion
routing
now
alice
has
a
secure
channel
with
the
tor
k
b
c
pub
pub
b
c
priv
priv
k
tor
relay
tor
exit
node
onion
routing
alice
will
do
a
key
exchange
with
the
tor
exit
but
she
will
do
it
using
the
tor
relay
as
a
proxy
pub
pub
k
b
c
pub
pub
b
c
priv
priv
k
tor
relay
tor
exit
node
onion
routing
now
alice
has
a
secure
channel
with
the
tor
exit
but
only
through
the
tor
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
now
see
alice
send
a
message
to
message
for
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
alice
wraps
the
original
packet
in
two
layers
of
k
k
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
the
tor
relay
can
decrypt
one
then
send
the
packet
to
the
next
k
k
k
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
the
exit
node
can
see
the
original
packet
but
not
the
original
k
k
k
m
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
finally
receives
the
message
for
k
k
k
m
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
of
course
will
send
a
response
back
to
the
tor
exit
but
how
does
it
get
back
from
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
has
no
idea
communicating
with
a
tor
response
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
the
tor
exit
node
make
the
same
kind
of
chain
that
alice
did
only
alice
knows
all
the
aes
response
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
instead
of
removing
layers
of
encryption
on
the
way
nodes
add
layers
of
k
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
the
tor
relay
know
what
data
it
only
knows
where
the
data
is
k
k
k
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
alice
can
remove
all
layers
of
r
k
k
k
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
this
channel
from
alice
to
is
called
a
tor
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
at
each
each
tor
node
only
knows
where
the
packet
has
been
and
where
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
only
the
exit
node
can
actually
see
the
packet
alice
is
k
b
c
pub
pub
k
b
c
priv
priv
k
tor
relay
k
tor
exit
node
onion
routing
there
are
thousands
of
tor
exit
onion
routing
alice
starts
the
whole
process
by
selecting
a
chain
of
tor
hidden
services
there
are
also
hidden
services
on
which
are
only
accessible
through
tor
hidden
services
we
will
not
discuss
hidden
services
in
but
you
actually
do
have
the
knowledge
now
to
understand
how
they
applied
crypto
advanced
topics
llc
all
rights
reserved
review
rsa
keys
llc
all
rights
reserved
today
bitcoin
llc
all
rights
reserved
bitcoin
what
is
bitcoin
is
a
digital
asset
designed
to
work
as
a
medium
of
exchange
using
cryptography
to
secure
the
llc
all
rights
reserved
bitcoin
why
have
there
is
no
bitcoin
banks
one
entity
in
charge
that
we
have
no
real
choice
but
to
single
points
of
in
a
centralization
bitcoin
seeks
to
eliminate
the
need
for
a
are
they
llc
all
rights
reserved
bitcoin
who
made
satoshi
published
his
original
paper
in
is
a
and
his
real
dorian
a
systems
identity
remains
engineer
in
was
briefly
this
has
made
for
some
believed
to
be
the
inventor
of
amusing
mistaken
identity
llc
all
rights
reserved
transactions
before
we
talk
about
talk
about
llc
all
rights
reserved
transactions
why
does
money
have
but
money
only
has
value
because
we
say
it
llc
all
rights
reserved
transactions
these
monetary
transactions
are
frequently
just
numbers
being
moved
around
on
a
llc
all
rights
reserved
a
public
ledger
instead
of
carrying
around
pockets
of
we
could
make
a
money
system
that
simply
posts
transactions
to
a
common
llc
all
rights
reserved
a
public
ledger
to
check
your
account
for
just
go
to
the
bulletin
board
add
up
all
the
money
been
and
subtract
all
the
money
llc
all
rights
reserved
phony
since
money
is
is
it
possible
for
people
to
make
this
problem
can
be
solved
by
enforcing
ownership
of
llc
all
rights
reserved
who
a
everybody
gets
two
things
an
address
a
signing
key
llc
all
rights
reserved
aside
by
the
in
we
have
software
that
addresses
signatures
transactions
that
you
have
to
generate
all
this
stuff
by
llc
all
rights
reserved
who
a
signatures
can
be
but
i
hereby
give
alice
the
key
used
to
sign
is
i
received
btc
in
tx
my
so
only
the
holder
of
the
key
can
generate
addresses
and
for
alice
to
spend
this
she
signing
keys
are
so
that
only
must
prove
ownership
with
when
i
make
a
bitcoin
her
i
can
use
an
bob
address
to
require
a
specific
llc
all
rights
reserved
who
a
addresses
and
signing
keys
are
llc
all
rights
reserved
phony
so
phony
spending
can
be
eliminated
by
verifying
that
the
funds
being
spent
exist
already
in
the
that
the
person
spending
it
has
the
signature
to
match
the
llc
all
rights
reserved
more
on
a
bitcoin
transaction
must
i
hereby
give
alice
i
received
btc
in
tx
have
the
my
a
sender
a
recipient
a
quantity
for
alice
to
spend
this
she
a
proof
of
funds
only
must
prove
ownership
with
her
a
signature
bob
llc
all
rights
reserved
network
the
transaction
is
then
sent
to
the
nearest
and
is
eventually
propagated
across
the
entire
another
llc
all
rights
reserved
double
spending
suppose
mallory
buys
a
computer
from
alice
for
before
the
transaction
is
posted
to
the
mallory
uses
the
same
bitcoins
to
buy
a
bicycle
in
a
transaction
to
or
at
least
before
bob
sees
llc
all
rights
reserved
double
spending
double
spending
is
a
serious
much
of
the
technology
that
goes
into
bitcoin
technology
is
to
eliminate
llc
all
rights
reserved
double
spending
we
want
to
ensure
that
only
valid
transactions
make
it
onto
the
public
ledger
everybody
has
the
same
ledger
bad
guy
could
theoretically
fork
the
ledger
to
omit
the
transaction
that
spent
his
llc
all
rights
reserved
double
spending
ignored
by
tx
to
alice
network
public
ledger
everyone
agrees
ledger
everyone
tx
to
bob
agrees
on
mallory
got
herself
a
computer
and
a
and
as
far
as
everyone
is
she
only
spent
the
bitcoins
llc
all
rights
reserved
as
currently
described
too
easy
to
fork
the
to
combat
there
should
be
a
tiny
bit
of
difficulty
to
add
new
proving
to
the
world
that
you
your
did
something
is
called
llc
all
rights
reserved
the
goal
is
to
add
a
new
transaction
to
the
public
someone
must
solve
a
suitably
difficult
mathematical
the
puzzle
should
be
hard
to
but
it
should
be
easy
to
it
should
also
have
some
connection
with
the
to
be
llc
all
rights
reserved
suppose
each
letter
corresponds
to
a
number
b
and
so
define
the
value
of
a
word
as
the
sum
of
the
letter
values
llc
all
rights
reserved
computing
the
value
of
a
given
word
like
example
is
the
challenge
would
be
to
find
a
valid
english
word
with
a
value
llc
all
rights
reserved
i
had
to
guess
and
check
words
to
find
llc
all
rights
reserved
bonus
slide
the
math
used
as
is
find
me
a
message
with
a
hash
that
starts
with
twenty
is
called
a
partial
llc
all
rights
reserved
blocks
transactions
are
aggregated
into
to
tx
or
so
per
the
block
is
then
hashed
over
and
over
it
until
the
target
is
llc
all
rights
reserved
blocks
each
block
contains
a
set
of
transactions
its
a
link
to
the
previous
block
this
link
from
block
to
block
llc
all
rights
reserved
the
block
chain
the
green
block
is
the
or
genesis
due
to
network
forks
inevitably
but
we
eventually
agree
on
the
block
llc
all
rights
reserved
the
block
chain
for
expensive
transactions
the
bicycle
or
the
the
is
to
make
sure
a
transaction
is
blocks
deep
before
considering
it
llc
all
rights
reserved
what
incentive
is
there
to
find
llc
all
rights
reserved
block
part
of
the
joy
of
discovering
a
new
block
is
that
you
include
a
reward
of
btc
to
if
you
include
the
right
it
be
considered
a
valid
the
rewards
decline
over
the
process
of
finding
a
new
block
is
called
llc
all
rights
reserved
miners
the
job
of
a
bitcoin
miner
is
collect
valid
transactions
into
a
hash
the
block
until
a
given
target
is
broadcast
the
new
block
to
the
llc
all
rights
reserved
miners
the
competition
is
to
have
a
lot
of
fast
and
specific
this
is
a
bitcoin
mining
llc
all
rights
reserved
miners
not
everybody
needs
to
be
should
a
but
without
there
is
no
and
therefore
no
llc
all
rights
reserved
double
spending
to
fork
the
the
bad
guy
would
need
to
have
more
computing
power
than
at
least
half
of
the
llc
all
rights
reserved
attack
if
a
single
entity
group
of
had
control
of
of
the
hashing
power
of
the
they
could
fork
the
blockchain
however
power
gives
in
there
is
a
significant
probability
of
success
with
only
of
the
they
computing
llc
all
rights
reserved
attack
in
some
llc
all
rights
reserved
attack
mining
pools
we
are
not
currently
in
any
danger
of
a
single
group
getting
llc
all
rights
reserved
bonus
slide
as
an
not
everybody
needs
to
have
a
copy
of
the
full
ledger
entire
block
chain
is
more
than
this
places
some
control
in
the
subset
of
people
who
do
keep
a
llc
all
rights
reserved
profitability
of
mining
antminer
per
costs
runs
at
kilowatts
total
mining
per
second
blocks
are
mined
at
about
block
per
minutes
about
blocks
per
month
btc
per
block
llc
all
rights
reserved
profitability
of
mining
about
new
bitcoins
per
month
btc
million
per
month
a
single
antminer
represents
about
of
the
total
mining
llc
all
rights
reserved
profitability
of
mining
one
antminer
running
at
full
capacity
brings
in
a
revenue
of
per
if
the
cost
of
electricity
in
colorado
is
cents
per
then
running
a
kilowatt
machine
hours
a
days
a
gives
us
and
therefore
an
electricity
cost
of
per
month
llc
all
rights
reserved
profitability
of
mining
this
gives
us
a
net
return
of
around
a
since
the
antminer
is
we
will
start
making
an
actual
profit
after
the
antminer
computes
hashes
at
trillion
hashes
per
second
if
doing
any
less
than
bother
because
just
wasting
llc
all
rights
reserved
profitability
of
mining
why
these
llc
all
rights
reserved
conclusion
bitcoin
is
there
are
present
security
risks
we
need
to
be
aware
there
is
a
big
drain
on
and
bother
mining
them
the
same
could
be
said
of
llc
all
rights
reserved
other
can
we
make
something
llc
all
rights
reserved
applied
crypto
advanced
topics
review
prime
numbers
rsa
keys
today
heartbleed
memory
in
order
to
discuss
how
the
heartbleed
bug
it
is
necessary
to
talk
about
memory
is
an
electronic
medium
for
storing
and
retrieving
memory
when
running
a
the
program
exists
in
ram
access
also
known
as
volatile
segments
for
a
given
memory
is
broken
into
the
segments
are
organized
as
initialized
uninitialized
heap
allocated
stack
segments
we
will
frequently
low
memory
draw
memory
with
low
memory
address
at
the
and
high
memory
heap
unallocated
addresses
stack
at
the
high
memory
stack
frames
as
we
the
stack
contains
function
frames
call
stack
frame
stack
grows
toward
low
stack
frame
stack
frame
stack
frames
stack
frames
are
a
way
to
maintain
isolation
between
this
allows
for
local
variables
to
remain
strictly
inside
the
scope
of
the
stack
frames
because
of
the
way
data
is
organized
on
the
there
are
occasionally
vulnerabilities
involving
improper
buffers
we
define
a
buffer
as
a
temporary
memory
area
in
which
data
is
stored
while
it
is
being
processed
or
buffers
if
i
have
a
program
that
performs
improper
i
may
open
myself
up
to
buffer
overreads
can
read
into
buffer
overflows
can
write
into
buffers
if
i
have
a
program
that
performs
improper
i
may
open
myself
up
to
buffer
overreads
can
read
into
buffer
overflows
can
write
into
heartbeat
some
buggy
code
found
its
way
into
the
openssl
suite
in
march
heartbeat
some
buggy
code
found
its
way
into
the
openssl
suite
in
march
flaw
was
not
discovered
immediately
until
april
heartbeat
the
rfc
heartbeat
extension
tests
secure
communication
links
by
allowing
a
computer
at
one
end
of
a
connection
to
send
a
consisting
of
a
typically
a
text
along
with
the
length
as
a
heartbeat
dear
been
quiet
for
a
are
you
still
if
respond
with
heartbeat
user
bob
wants
to
user
dave
wants
to
change
user
alice
wants
user
charlie
entered
user
eve
wants
bob
entered
passw
heartbeat
wolf
heartbleed
the
heartbeat
code
does
not
automatically
check
to
make
sure
the
length
of
the
payload
is
the
same
as
the
number
sent
in
the
heartbleed
this
means
that
malicious
users
can
send
short
but
request
up
to
bytes
in
the
return
the
server
will
read
out
of
memory
be
and
return
it
to
the
user
that
made
the
heartbleed
the
heartbeat
extension
was
coded
to
be
enabled
by
default
in
meaning
that
when
the
buggy
code
went
every
server
with
that
implementation
of
openssl
was
some
argue
that
heartbleed
is
the
worst
vulnerability
found
least
in
terms
of
its
potential
since
commercial
traffic
began
to
flow
on
the
heartbleed
dear
been
quiet
for
a
are
you
still
if
respond
with
heartbleed
user
bob
wants
to
user
dave
wants
to
change
user
alice
wants
user
charlie
entered
user
eve
wants
bob
entered
passw
heartbleed
user
charlie
entered
user
eve
wants
bob
entered
heartbleed
although
an
attacker
has
some
control
over
the
disclosed
memory
it
has
no
control
over
its
and
therefore
cannot
choose
what
content
is
heartbleed
finding
sensitive
data
in
the
memory
of
the
running
openssl
server
is
tricky
and
the
heartbleed
exploit
we
use
in
this
lab
uses
the
where
it
looks
for
p
or
q
in
the
dumped
memory
and
tries
to
divide
it
into
the
public
rsa
modulus
obtained
from
the
cert
supplied
at
handshake
defenses
the
problem
can
be
fixed
by
ignoring
heartbeat
request
messages
that
ask
for
more
data
than
their
payload
the
problem
could
also
be
fixed
by
simply
disabling
the
heartbeat
extension
by
applied
crypto
advanced
topics
review
aes
cbc
mode
today
padding
oracle
attacks
what
is
an
oracle
how
does
padding
work
for
aes
recall
aes
stands
for
advanced
encryption
standard
aes
takes
bits
as
input
takes
or
bits
as
a
key
outputs
bits
of
ciphertext
cbc
mode
since
aes
only
functions
on
blocks
of
we
need
to
extend
it
to
longer
cipher
block
chaining
mode
is
a
mode
of
operation
for
accomplishing
cbc
mode
one
problem
we
can
now
use
to
encrypt
more
than
the
only
problem
is
that
sometimes
a
plaintext
is
not
exactly
a
multiple
of
bits
padding
standard
we
need
a
standard
way
to
pad
rfc
for
contains
pkcs
key
cryptography
pkcs
pkcs
specifies
a
standardized
method
for
padding
plaintexts
to
ensure
the
length
of
the
plaintext
is
an
exact
multiple
of
the
block
cipher
block
pkcs
in
the
case
of
the
block
size
is
bits
so
the
padding
standard
describes
how
to
pad
plaintexts
to
a
length
an
exact
multiple
of
pkcs
the
plaintext
is
padded
at
the
trailing
end
with
one
of
the
following
if
length
mod
if
length
mod
if
length
mod
bytes
of
pkcs
the
padding
can
be
removed
unambiguously
since
all
input
is
padded
if
the
plaintext
is
a
multiple
of
bytes
to
begin
it
is
still
oracle
machines
an
oracle
machine
is
an
entity
that
responds
to
a
and
is
capable
of
solving
a
specific
one
can
think
of
it
as
a
black
box
that
is
able
to
produce
a
solution
for
any
instance
of
a
given
computational
examples
the
google
search
engine
can
be
thought
of
as
an
the
query
the
user
makes
is
a
literal
search
the
response
from
the
oracle
is
in
the
form
is
what
exists
in
my
examples
any
server
could
be
considered
an
the
query
the
user
makes
could
be
a
ping
you
the
response
is
either
or
padding
oracles
a
padding
oracle
has
the
following
it
is
an
oracle
machine
that
has
a
symmetric
key
stored
users
send
the
oracle
some
ciphertext
the
oracle
decrypts
the
ciphertext
using
the
key
padding
oracles
a
padding
oracle
has
the
following
the
oracle
checks
the
padding
of
the
resulting
the
oracle
sends
a
message
to
the
user
equivalent
to
padding
is
or
padding
is
not
according
to
pkcs
note
this
or
response
could
look
and
it
is
up
to
the
user
to
decide
what
the
responses
note
for
it
could
be
that
a
answer
is
the
server
responding
to
the
user
with
a
new
encrypted
and
a
answer
is
the
server
simply
echoing
back
the
bad
note
for
another
it
could
be
that
a
answer
is
the
server
responding
to
the
user
in
and
a
answer
is
the
server
responding
to
the
user
in
note
it
is
important
to
remember
that
the
existence
of
a
padding
oracle
is
an
is
a
systems
administrators
are
not
implementing
these
for
fun
in
an
padding
oracle
attack
this
attack
is
mostly
associated
with
cbc
but
there
are
other
modes
and
padding
schemes
that
may
be
the
last
byte
first
suppose
we
have
two
ciphertext
blocks
c
and
c
with
we
want
to
decrypt
c
to
get
the
plaintext
p
the
the
last
byte
first
assume
these
are
simply
two
blocks
in
the
middle
of
the
ciphertext
p
is
probably
not
padded
we
have
a
padding
oracle
to
send
data
so
we
can
find
out
if
the
plaintext
corresponding
to
the
ciphertext
is
correctly
padded
or
the
last
byte
first
typical
cbc
mode
decryption
looks
like
this
for
p
the
last
byte
first
observe
that
c
is
combined
with
the
data
coming
out
of
aes
using
the
xor
operation
to
produce
p
the
last
byte
first
this
is
actually
quite
powerful
because
we
have
control
of
c
the
last
byte
first
the
goal
here
is
to
change
the
last
byte
in
c
and
resubmit
the
altered
ciphertext
to
the
padding
keep
changing
that
last
byte
until
we
can
force
the
decrypted
plaintext
to
end
with
the
byte
we
will
then
get
a
positive
answer
from
the
the
last
byte
first
redraw
the
previous
diagram
but
name
the
block
coming
out
of
aes
it
is
xored
with
c
as
the
last
byte
first
call
the
last
byte
of
c
b
call
the
last
byte
of
a
a
call
the
last
byte
of
p
z
b
a
z
the
attack
the
first
part
of
the
attack
is
to
replace
b
with
b
z
of
since
we
do
not
know
the
actual
value
of
z
we
are
merely
the
attack
we
will
be
able
to
determine
the
correct
value
of
z
in
guesses
or
call
the
new
value
b
b
b
z
the
attack
denote
the
new
block
formed
by
replacing
b
by
b
by
c
as
in
the
the
decrypted
plaintext
will
no
longer
be
p
is
replaced
with
p
the
attack
the
last
byte
in
p
will
not
be
z
it
will
be
z
we
have
not
yet
the
attack
we
can
compute
z
by
using
what
we
know
about
the
other
bytes
and
xor
the
attack
z
b
a
z
a
b
a
z
z
z
the
attack
what
this
means
is
that
and
when
we
guess
the
correct
value
of
z
the
padding
oracle
will
find
as
the
last
byte
of
which
matter
what
the
rest
of
the
bytes
indicates
correct
the
attack
as
we
cycle
through
guesses
of
z
we
will
get
many
negative
responses
from
the
padding
the
attack
when
we
get
a
positive
we
record
the
value
of
z
that
prompted
the
positive
and
then
we
can
move
on
to
the
next
the
byte
after
we
have
guessed
the
last
byte
of
p
we
can
repeat
a
similar
attack
to
obtain
the
byte
of
p
this
we
alter
the
last
two
bytes
of
c
the
byte
observe
that
the
same
nomenclature
to
name
we
have
the
following
b
a
z
the
byte
similar
to
replace
b
with
b
z
we
know
the
exact
value
of
z
replace
b
with
b
z
we
do
not
know
the
exact
value
of
z
so
we
are
guessing
to
the
byte
send
the
altered
ciphertext
to
the
padding
when
we
guess
z
the
padding
oracle
will
find
as
the
last
two
bytes
in
the
decrypted
plaintext
and
will
give
a
positive
the
byte
record
the
value
of
z
that
made
this
work
and
move
on
to
the
next
the
rest
all
sixteen
bytes
in
p
can
be
recovered
using
this
the
rest
as
this
attack
requires
two
blocks
of
ciphertext
in
order
to
for
if
we
have
twenty
blocks
of
take
the
blocks
in
pairs
to
sequentially
decrypt
each
use
c
and
c
to
break
p
use
c
and
c
to
break
p
use
c
and
c
to
break
p
the
rest
how
do
you
break
p
the
iv
plays
the
same
role
for
c
that
c
plays
for
c
the
same
attack
can
therefore
be
reused
with
the
iv
and
c
in
order
to
decrypt
p
defenses
a
padding
oracle
vulnerability
often
comes
about
because
of
improper
defenses
one
solid
defense
against
padding
oracle
attacks
is
to
use
an
defenses
this
the
mac
is
computed
on
the
so
the
server
will
verify
authenticity
before
doing
any
decryption
at
if
the
authenticity
check
do
not
defenses
since
an
attacker
cannot
forge
a
he
cannot
force
the
server
to
try
to
decrypt
his
altered
ciphertexts
the
server
will
not
send
responses
that
leak
information
about
the
applied
crypto
advanced
topics
review
xor
pad
stream
ciphers
today
wep
and
the
fms
attack
is
a
stream
cipher
originally
designed
by
ron
rivest
in
initially
a
trade
a
description
of
was
anonymously
posted
to
the
internet
in
confirmed
to
be
accurate
after
simple
comparisons
with
ciphertext
encrypted
using
proprietary
software
licensed
with
ksa
employs
a
key
scheduling
algorithm
to
extend
a
short
key
into
a
ksa
pseudocode
def
s
j
for
i
from
to
j
mod
mod
swap
ksa
pseudocode
def
s
j
for
i
from
to
j
mod
mod
swap
are
going
to
need
this
so
take
a
or
look
it
up
on
ksa
the
ksa
starts
with
a
array
initialized
to
the
integers
from
to
in
it
ends
with
a
array
with
swaps
based
on
the
key
still
contains
the
numbers
from
to
just
not
in
prga
the
second
important
component
of
is
the
generation
algorithm
this
is
the
function
that
will
output
bytes
to
be
used
in
the
stream
prga
pseudocode
def
i
j
while
i
mod
j
mod
swap
yield
mod
prga
pseudocode
def
i
j
while
i
mod
j
mod
swap
yield
mod
this
wep
wep
equivalent
was
included
as
the
privacy
component
of
the
original
ieee
standard
ratified
in
wep
wep
uses
the
stream
cipher
for
standard
wep
uses
a
key
and
a
initialization
vector
to
form
the
wep
with
regard
to
best
ivs
should
only
be
used
due
to
the
short
ivs
there
are
only
million
possible
so
an
attacker
can
guarantee
the
appearance
of
given
wep
the
standard
subnetwork
access
protocol
header
is
always
the
that
the
first
byte
of
any
wep
packet
plaintext
is
always
this
will
be
important
wep
a
paper
published
in
described
a
fast
and
passive
packets
need
to
be
attack
to
recover
keys
after
eavesdropping
for
long
enough
on
a
network
using
fms
attack
this
attack
on
wep
to
recover
wep
keys
is
called
the
and
shamir
named
after
the
researchers
who
discovered
shamir
from
fms
attack
the
attack
succeeds
because
repeated
initialization
vectors
predictable
values
in
known
wep
snap
header
fms
attack
for
the
following
assume
that
the
wep
key
can
be
written
in
the
following
are
the
three
bytes
of
the
iv
are
the
five
bytes
of
the
fms
attack
we
are
going
to
use
what
we
know
about
the
ksa
and
the
prga
to
try
to
crack
the
part
of
the
attack
the
attacker
simply
obtaining
ciphertexts
with
ivs
attached
to
each
fms
attack
this
part
of
the
attack
relies
on
the
fact
that
since
there
are
only
possible
ivs
the
attacker
can
wait
for
ivs
of
a
given
the
attacker
will
simply
ignore
ivs
that
fit
a
given
the
first
byte
of
the
key
assume
the
attacker
can
obtain
ivs
of
the
form
where
x
is
any
number
from
to
we
will
walk
through
four
rounds
of
the
ksa
to
see
how
it
will
affect
the
random
numbers
generated
from
the
round
we
start
with
s
using
the
ksa
we
have
i
j
mod
after
s
round
increment
to
i
j
mod
after
s
round
increment
to
i
j
mod
after
s
we
now
have
to
make
a
probabilistic
for
this
to
we
need
j
there
is
almost
a
chance
that
this
round
increment
to
i
j
mod
after
s
this
only
works
about
a
chance
of
round
before
round
we
have
s
for
rounds
we
want
the
following
three
entries
in
s
to
remain
there
is
about
a
chance
that
this
the
prga
following
the
prga
we
will
simply
compute
the
first
byte
assuming
the
s
array
from
the
ksa
has
this
s
start
with
i
j
and
i
j
output
mod
x
conclusion
the
first
byte
in
the
keystream
produced
by
the
prga
will
be
x
the
attacker
can
also
see
the
first
byte
of
the
since
we
also
know
the
first
byte
of
the
plaintext
is
the
wep
snap
header
we
can
simply
compute
conclusion
x
x
x
arithmetic
is
reduced
modulo
but
wait
this
attack
is
it
only
produces
candidate
values
of
the
real
value
of
will
show
up
about
of
the
if
i
try
different
values
of
the
real
value
of
on
show
up
about
or
times
more
than
the
other
table
a
table
to
x
ciphertext
potential
final
then
tally
up
potential
potential
count
this
will
tell
us
which
is
the
true
value
of
beyond
it
is
fairly
simple
to
use
this
outline
to
recover
and
